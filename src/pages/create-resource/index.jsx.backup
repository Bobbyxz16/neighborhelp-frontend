import React, { useState, useEffect, useCallback } from 'react';
import { useNavigate } from 'react-router-dom';
import Header from '../../components/ui/ui-components/Header';
import Button from '../../components/ui/ui-components/Button';
import Icon from '../../components/ui/AppIcon';
import BasicInfoSection from './components/BasicInfoSection';
import LocationSection from './components/LocationSection';
import AvailabilitySection from './components/AvailabilitySection';
import ContactSection from './components/ContactSection';
import EligibilitySection from './components/EligibilitySection';
import CostSection from './components/CostSection';
import MediaSection from './components/MediaSection';
import ReviewSection from './components/ReviewSection';
import { API_BASE_URL, API_ENDPOINTS, STORAGE_KEYS } from '../../utils/constants';
import api from '../../api/axios';

const CreateResourceListing = () => {
  const navigate = useNavigate();
  const [currentStep, setCurrentStep] = useState(1);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [isDraftSaving, setIsDraftSaving] = useState(false);
  const [lastSaved, setLastSaved] = useState(null);
  const [errors, setErrors] = useState({});
  const [categories, setCategories] = useState([]);

  // Simplified form data structure matching your backend
  const [formData, setFormData] = useState({
    // Basic Info
    title: '',
    description: '',
    category: '',

    // Location
    city: '',
    street: '',
    postalCode: '',
    province: '',
    country: 'England',

    // Contact & Availability
    contactName: '',
    phoneNumber: '',
    email: '',
    website: '',
    preferredContactMethods: [],
    responseTime: '',
    contactHours: '',
    contactInstructions: '',
    emergencyContact: false,
    emergencyPhone: '',
    emergencyHours: '',

    // Availability fields
    operatingDays: [],
    timeSlots: [],
    isSeasonal: false,
    seasonStart: '',
    seasonEnd: '',
    seasonalNotes: '',
    scheduleNotes: '',
    appointmentType: '',
    capacity: '',

    // Cost
    cost: 'FREE',

    // Additional fields from your backend
    requirements: '',
    additionalNotes: '',
    wheelchairAccessible: false,
    languages: [],
    targetAudience: '',
    imageUrl: '',
    websiteUrl: '',

    // Review confirmations
    confirmAccuracy: false,
    agreeToTerms: false,
    understandReview: false,
  });

  // Build a per-user draft key so drafts are isolated by user
  const getDraftKey = () => {
    try {
      const userJson = localStorage.getItem(STORAGE_KEYS.USER);
      if (!userJson) return 'resourceListingDraft_anonymous';

      const user = JSON.parse(userJson);
      const idPart = user?.id || user?.email || user?.username || 'anonymous';
      return `resourceListingDraft_${idPart}`;
    } catch {
      return 'resourceListingDraft_anonymous';
    }
  };

  const steps = [
    { id: 1, title: 'Basic Info', icon: 'FileText', component: BasicInfoSection },
    { id: 2, title: 'Location', icon: 'MapPin', component: LocationSection },
    { id: 3, title: 'Availability', icon: 'Clock', component: AvailabilitySection },
    { id: 4, title: 'Contact', icon: 'Phone', component: ContactSection },
    { id: 5, title: 'Eligibility', icon: 'Users', component: EligibilitySection },
    { id: 6, title: 'Cost', icon: 'DollarSign', component: CostSection },
    { id: 7, title: 'Photos', icon: 'Camera', component: MediaSection },
    { id: 8, title: 'Review', icon: 'CheckCircle', component: ReviewSection }
  ];

  // Load categories and any saved draft on component mount
  useEffect(() => {
    loadCategories();
    try {
      const draftKey = getDraftKey();
      const saved = localStorage.getItem(draftKey);
      if (saved) {
        const parsed = JSON.parse(saved);
        setFormData(prev => ({ ...prev, ...parsed }));
      }

      // Cleanup legacy global draft key if it exists
      localStorage.removeItem('resourceListingDraft');
    } catch (err) {
      console.error('Failed to load saved draft:', err);
    }
  }, []);

  // Define handleAutoSave with useCallback to prevent unnecessary re-renders
  const handleAutoSave = useCallback(async () => {
    try {
      const hasData = Object.values(formData).some((v) => {
        if (typeof v === 'string') return v.trim() !== '';
        if (Array.isArray(v)) return v.length > 0;
        if (typeof v === 'boolean') return v === true;
        return v != null;
      });
      if (hasData) {
        const draftKey = getDraftKey();
        localStorage.setItem(draftKey, JSON.stringify(formData));
        setLastSaved(new Date());
      }
    } catch (error) {
      console.error('Auto-save failed:', error);
    }
  }, [formData]);

  // Auto-save functionality
  useEffect(() => {
    const autoSaveInterval = setInterval(() => {
      handleAutoSave();
    }, 30000);

    return () => clearInterval(autoSaveInterval);
  }, [handleAutoSave]); // Now handleAutoSave is a dependency

  const loadCategories = async () => {
    try {
      const { data } = await api.get(API_ENDPOINTS.CATEGORIES.BASE);
      setCategories(data || []);
    } catch (error) {
      console.error('Failed to load categories:', error);
    }
  };

  const handleInputChange = (field, value) => {
    setFormData(prev => ({
      ...prev,
      [field]: value
    }));

    // Clear error when user starts typing
    if (errors[field]) {
      setErrors(prev => ({
        ...prev,
        [field]: ''
      }));
    }
  };

  const validateStep = (stepNumber) => {
    const stepErrors = {};

    switch (stepNumber) {
      case 1: // Basic Info
        if (!formData.title.trim()) stepErrors.title = 'Title is required';
        if (!formData.category) stepErrors.category = 'Category is required';
        if (!formData.description.trim() || formData.description.length < 20) {
          stepErrors.description = 'Description must be at least 20 characters';
        }
        break;

      case 2: // Location
        if (!formData.city.trim()) stepErrors.city = 'City is required';
        if (!formData.street.trim()) stepErrors.street = 'Street address is required';
        if (!formData.postalCode.trim()) stepErrors.postalCode = 'Postal code is required';
        break;

      case 3: // Availability
        if (!Array.isArray(formData.operatingDays) || formData.operatingDays.length === 0) {
          stepErrors.operatingDays = 'Select at least one operating day';
        }
        if (Array.isArray(formData.timeSlots) && formData.timeSlots.length > 0) {
          const invalidSlot = formData.timeSlots.find(s => s?.startTime && s?.endTime && s.endTime <= s.startTime);
          if (invalidSlot) {
            stepErrors.timeSlots = 'Each time slot must have an end time after the start time';
          }
        }
        if (formData.isSeasonal) {
          if (!formData.seasonStart || !formData.seasonEnd) {
            stepErrors.season = 'Season start and end are required when Seasonal Service is enabled';
          } else if (formData.seasonEnd < formData.seasonStart) {
            stepErrors.season = 'Season end must be on or after the season start';
          }
        }
        break;

      case 4: // Contact
        if (!formData.contactName?.trim()) stepErrors.contactName = 'Primary contact name is required';
        if (!formData.phoneNumber?.trim()) stepErrors.phoneNumber = 'Phone number is required';
        if (!formData.email?.trim()) stepErrors.email = 'Email address is required';
        if (!Array.isArray(formData.preferredContactMethods) || formData.preferredContactMethods.length === 0) {
          stepErrors.preferredContactMethods = 'Select at least one preferred contact method';
        }
        if (!formData.responseTime) stepErrors.responseTime = 'Response time is required';
        break;
    }

    setErrors(stepErrors);
    return Object.keys(stepErrors).length === 0;
  };

  const handleNext = () => {
    if (currentStep === 3) {
      // Run validation to surface errors but do not block navigation on Availability step
      validateStep(3);
      setCurrentStep(prev => Math.min(prev + 1, steps.length));
    } else if (validateStep(currentStep)) {
      setCurrentStep(prev => Math.min(prev + 1, steps.length));
    }
  };

  const handlePrevious = () => {
    setCurrentStep(prev => Math.max(prev - 1, 1));
  };

  const handleStepClick = (stepNumber) => {
    if (stepNumber <= currentStep || validateStep(currentStep)) {
      setCurrentStep(stepNumber);
    }
  };

  const handleSaveDraft = async () => {
    setIsDraftSaving(true);
    try {
      await new Promise((resolve) => setTimeout(resolve, 1000));
      const draftKey = getDraftKey();
      localStorage.setItem(draftKey, JSON.stringify(formData));
      setLastSaved(new Date());
      alert('Draft saved successfully!');
    } catch (error) {
      console.error('Failed to save draft:', error);
      alert('Failed to save draft. Please try again.');
    } finally {
      setIsDraftSaving(false);
    }
  };

  const CurrentStepComponent = steps.find(s => s.id === currentStep)?.component;
  const progressPercentage = Math.min(100, Math.round(((currentStep - 1) / (steps.length - 1 || 1)) * 100));

  const handleSubmit = async () => {
    if (!validateStep(currentStep)) return;

    setIsSubmitting(true);

    const normalizeCapacity = (value) => {
      if (!value) return undefined;
      if (typeof value === 'number') return value;
      const v = String(value).toLowerCase();
      if (v === 'unlimited') return undefined; // omit from payload
      if (/^\d+$/.test(v)) return parseInt(v, 10);
      if (/^\d+-\d+$/.test(v)) {
        const [, max] = v.split('-');
        return parseInt(max, 10);
      }
      if (/^\d+\+$/.test(v)) {
        return parseInt(v.replace('+', ''), 10);
      }
      return undefined; // unknown format -> omit
    };

    const contactParts = [];
    if (formData.contactName?.trim()) contactParts.push(`Name: ${formData.contactName.trim()}`);
    if (formData.phoneNumber?.trim()) contactParts.push(`Tel: ${formData.phoneNumber.trim()}`);
    if (formData.email?.trim()) contactParts.push(`Email: ${formData.email.trim()}`);
    const websiteStr = formData.websiteUrl?.trim() || formData.website?.trim();
    if (websiteStr) contactParts.push(`Web: ${websiteStr}`);
    if (Array.isArray(formData.preferredContactMethods) && formData.preferredContactMethods.length) {
      contactParts.push(`Preferred: ${formData.preferredContactMethods.join(',')}`);
    }
    { id: 7, title: 'Photos', icon: 'Camera', component: MediaSection },
    { id: 8, title: 'Review', icon: 'CheckCircle', component: ReviewSection }
  ];

// Load categories and any saved draft on component mount
useEffect(() => {
  loadCategories();
  try {
    const draftKey = getDraftKey();
    const saved = localStorage.getItem(draftKey);
    if (saved) {
      const parsed = JSON.parse(saved);
      setFormData(prev => ({ ...prev, ...parsed }));
    }

    // Cleanup legacy global draft key if it exists
    localStorage.removeItem('resourceListingDraft');
  } catch (err) {
    console.error('Failed to load saved draft:', err);
  }
}, []);

// Define handleAutoSave with useCallback to prevent unnecessary re-renders
const handleAutoSave = useCallback(async () => {
  try {
    const hasData = Object.values(formData).some((v) => {
      if (typeof v === 'string') return v.trim() !== '';
      if (Array.isArray(v)) return v.length > 0;
      if (typeof v === 'boolean') return v === true;
      return v != null;
    });
    if (hasData) {
      const draftKey = getDraftKey();
      localStorage.setItem(draftKey, JSON.stringify(formData));
      setLastSaved(new Date());
    }
  } catch (error) {
    console.error('Auto-save failed:', error);
  }
}, [formData]);

// Auto-save functionality
useEffect(() => {
  const autoSaveInterval = setInterval(() => {
    handleAutoSave();
  }, 30000);

  return () => clearInterval(autoSaveInterval);
}, [handleAutoSave]); // Now handleAutoSave is a dependency

const loadCategories = async () => {
  try {
    const { data } = await api.get(API_ENDPOINTS.CATEGORIES.BASE);
    setCategories(data || []);
  } catch (error) {
    console.error('Failed to load categories:', error);
  }
};

const handleInputChange = (field, value) => {
  setFormData(prev => ({
    ...prev,
    [field]: value
  }));

  // Clear error when user starts typing
  if (errors[field]) {
    setErrors(prev => ({
      ...prev,
      [field]: ''
    }));
  }
};

const validateStep = (stepNumber) => {
  const stepErrors = {};

  switch (stepNumber) {
    case 1: // Basic Info
      if (!formData.title.trim()) stepErrors.title = 'Title is required';
      if (!formData.category) stepErrors.category = 'Category is required';
      if (!formData.description.trim() || formData.description.length < 20) {
        stepErrors.description = 'Description must be at least 20 characters';
      }
      break;

    case 2: // Location
      if (!formData.city.trim()) stepErrors.city = 'City is required';
      if (!formData.street.trim()) stepErrors.street = 'Street address is required';
      if (!formData.postalCode.trim()) stepErrors.postalCode = 'Postal code is required';
      break;

    case 3: // Availability
      if (!Array.isArray(formData.operatingDays) || formData.operatingDays.length === 0) {
        stepErrors.operatingDays = 'Select at least one operating day';
      }
      if (Array.isArray(formData.timeSlots) && formData.timeSlots.length > 0) {
        const invalidSlot = formData.timeSlots.find(s => s?.startTime && s?.endTime && s.endTime <= s.startTime);
        if (invalidSlot) {
          stepErrors.timeSlots = 'Each time slot must have an end time after the start time';
        }
      }
      if (formData.isSeasonal) {
        if (!formData.seasonStart || !formData.seasonEnd) {
          stepErrors.season = 'Season start and end are required when Seasonal Service is enabled';
        } else if (formData.seasonEnd < formData.seasonStart) {
          stepErrors.season = 'Season end must be on or after the season start';
        }
      }
      break;

    case 4: // Contact
      if (!formData.contactName?.trim()) stepErrors.contactName = 'Primary contact name is required';
      if (!formData.phoneNumber?.trim()) stepErrors.phoneNumber = 'Phone number is required';
      if (!formData.email?.trim()) stepErrors.email = 'Email address is required';
      if (!Array.isArray(formData.preferredContactMethods) || formData.preferredContactMethods.length === 0) {
        stepErrors.preferredContactMethods = 'Select at least one preferred contact method';
      }
      if (!formData.responseTime) stepErrors.responseTime = 'Response time is required';
      break;
  }

  setErrors(stepErrors);
  return Object.keys(stepErrors).length === 0;
};

const handleNext = () => {
  if (currentStep === 3) {
    // Run validation to surface errors but do not block navigation on Availability step
    validateStep(3);
    setCurrentStep(prev => Math.min(prev + 1, steps.length));
  } else if (validateStep(currentStep)) {
    setCurrentStep(prev => Math.min(prev + 1, steps.length));
  }
};

const handlePrevious = () => {
  setCurrentStep(prev => Math.max(prev - 1, 1));
};

const handleStepClick = (stepNumber) => {
  if (stepNumber <= currentStep || validateStep(currentStep)) {
    setCurrentStep(stepNumber);
  }
};

const handleSaveDraft = async () => {
  setIsDraftSaving(true);
  try {
    await new Promise((resolve) => setTimeout(resolve, 1000));
    const draftKey = getDraftKey();
    localStorage.setItem(draftKey, JSON.stringify(formData));
    setLastSaved(new Date());
    alert('Draft saved successfully!');
  } catch (error) {
    console.error('Failed to save draft:', error);
    alert('Failed to save draft. Please try again.');
  } finally {
    setIsDraftSaving(false);
  }
};

const CurrentStepComponent = steps.find(s => s.id === currentStep)?.component;
const progressPercentage = Math.min(100, Math.round(((currentStep - 1) / (steps.length - 1 || 1)) * 100));

const handleSubmit = async () => {
  if (!validateStep(currentStep)) return;

  setIsSubmitting(true);

  const normalizeCapacity = (value) => {
    if (!value) return undefined;
    if (typeof value === 'number') return value;
    const v = String(value).toLowerCase();
    if (v === 'unlimited') return undefined; // omit from payload
    if (/^\d+$/.test(v)) return parseInt(v, 10);
    if (/^\d+-\d+$/.test(v)) {
      const [, max] = v.split('-');
      return parseInt(max, 10);
    }
    if (/^\d+\+$/.test(v)) {
      return parseInt(v.replace('+', ''), 10);
    }
    return undefined; // unknown format -> omit
  };

  const contactParts = [];
  if (formData.contactName?.trim()) contactParts.push(`Name: ${formData.contactName.trim()}`);
  if (formData.phoneNumber?.trim()) contactParts.push(`Tel: ${formData.phoneNumber.trim()}`);
  if (formData.email?.trim()) contactParts.push(`Email: ${formData.email.trim()}`);
  const websiteStr = formData.websiteUrl?.trim() || formData.website?.trim();
  if (websiteStr) contactParts.push(`Web: ${websiteStr}`);
  if (Array.isArray(formData.preferredContactMethods) && formData.preferredContactMethods.length) {
    contactParts.push(`Preferred: ${formData.preferredContactMethods.join(',')}`);
  }
  if (formData.contactInstructions?.trim()) contactParts.push(formData.contactInstructions.trim());
  if (formData.emergencyContact) {
    const e = [formData.emergencyPhone?.trim(), formData.emergencyHours?.trim()].filter(Boolean).join(' ');
    if (e) contactParts.push(`Emergency: ${e}`);
  }
  const contactInfo = contactParts.join(', ');

  let availability = '';
  if (Array.isArray(formData.operatingDays) && formData.operatingDays.length) {
    availability += formData.operatingDays.join(', ');
  }
  if (Array.isArray(formData.timeSlots) && formData.timeSlots.length) {
    const slots = formData.timeSlots
      .filter(s => s?.startTime && s?.endTime)
      .map(s => `${s.startTime}-${s.endTime}`)
      .join(', ');
    if (slots) availability += (availability ? ' ' : '') + slots;
  }
  if (formData.contactHours) availability += (availability ? ' ' : '') + formData.contactHours;
  if (formData.isSeasonal && (formData.seasonStart || formData.seasonEnd)) {
    const season = `${formData.seasonStart || ''}${formData.seasonStart && formData.seasonEnd ? ' to ' : ''}${formData.seasonEnd || ''}`.trim();
    if (season) availability += (availability ? '; ' : '') + `Season: ${season}`;
  }

  const payload = {
    title: formData.title.trim(),
    description: formData.description.trim(),
    categoryId: formData.category,
    subcategoryId: formData.subcategory || undefined,
    street: formData.street.trim(),
    city: formData.city.trim(),
    province: formData.province || 'Ontario',
    postalCode: formData.postalCode.trim(),
    country: formData.country || 'Canada',
    latitude: formData.latitude || undefined,
    longitude: formData.longitude || undefined,
    contactInfo,
    availability: availability || undefined,
    capacity: normalizeCapacity(formData.capacity),
    eligibility: formData.eligibility?.trim() || undefined,
    accessibility: formData.accessibility?.trim() || undefined,
    transportation: formData.transportation?.trim() || undefined,
    languages: Array.isArray(formData.languages) && formData.languages.length
      ? formData.languages.join(', ')
      : undefined,
    targetAudience: formData.targetAudience?.trim() || undefined,
    tags: Array.isArray(formData.tags) && formData.tags.length
      ? formData.tags.join(', ')
      : undefined,

    // FIX: Get the first image URL from the images array
    imageUrl: (formData.images && formData.images.length > 0)
      ? formData.images[0].url
      : undefined,

    websiteUrl: websiteStr || undefined,
  };

  try {
    const response = await api.post(API_ENDPOINTS.RESOURCES.BASE, payload);

    // Clear draft on successful submission
    const draftKey = getDraftKey();
    localStorage.removeItem(draftKey);

    alert('Resource submitted successfully! It will be reviewed by our team.');
    navigate('/user-dashboard');
  } catch (error) {
    console.error('Failed to submit resource:', error);
    const errorMessage = error.response?.data?.message || 'Failed to submit resource. Please try again.';
    alert(errorMessage);
  } finally {
    setIsSubmitting(false);
  }
};

return (
  <div className="min-h-screen bg-gray-50">
    {/* Header */}
    <div className="bg-white border-b border-gray-200">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <div className="flex justify-between items-center h-16">
          <div className="flex items-center space-x-2">
            <button
              onClick={() => navigate('/user-dashboard')}
              className="flex items-center space-x-2 text-gray-600 hover:text-gray-900"
            >
              <Icon name="ArrowLeft" size={20} />
              <span className="font-medium">Back to Dashboard</span>
            </button>
          </div>

          {lastSaved && (
            <div className="flex items-center space-x-2 text-sm text-gray-500">
              <Icon name="Save" size={16} />
              <span>Last saved: {lastSaved.toLocaleTimeString()}</span>
            </div>
          )}
        </div>
      </div>
    </div>

    <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
      {/* Page Header */}
      <div className="mb-8">
        <h1 className="text-3xl font-bold text-gray-900">Create Resource</h1>
        <p className="text-gray-600 mt-2">
          Share your resource with the community
        </p>
      </div>

      {/* Progress Bar */}
      <div className="mb-8">
        <div className="flex items-center justify-between mb-2">
          <span className="text-sm font-medium text-gray-900">
            Step {currentStep} of {steps.length}
          </span>
          <span className="text-sm text-gray-500">
            {Math.round(progressPercentage)}% Complete
          </span>
        </div>
        <div className="w-full bg-gray-200 rounded-full h-2">
          <div
            className="bg-blue-600 h-2 rounded-full transition-all duration-300"
            style={{ width: `${progressPercentage}%` }}
          />
        </div>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-4 gap-8">
        {/* Step Navigation */}
        <div className="lg:col-span-1">
          <div className="bg-white rounded-lg border border-gray-200 p-4 sticky top-24">
            <h2 className="font-semibold text-gray-900 mb-4">Steps</h2>
            <nav className="space-y-2">
              {steps.map((step) => (
                <button
                  key={step.id}
                  onClick={() => handleStepClick(step.id)}
                  className={`w-full flex items-center space-x-3 px-3 py-2 rounded-md text-left transition-colors ${currentStep === step.id
                    ? 'bg-blue-600 text-white'
                    : currentStep > step.id
                      ? 'bg-green-100 text-green-800 hover:bg-green-200'
                      : 'text-gray-600 hover:bg-gray-100'
                    }`}
                >
                  <Icon
                    name={currentStep > step.id ? 'CheckCircle' : step.icon}
                    size={16}
                  />
                  <span className="text-sm font-medium">{step.title}</span>
                </button>
              ))}
            </nav>
          </div>
        </div>

        {/* Main Content */}
        <div className="lg:col-span-3">
          <div className="bg-white rounded-lg border border-gray-200 p-6">
            <div className="space-y-6">
              {/* Render the current step component */}
              {CurrentStepComponent && (
                <CurrentStepComponent
                  formData={formData}
                  onChange={handleInputChange}
                  errors={errors}
                  categories={categories}
                  onSubmit={handleSubmit}
                  onSaveDraft={handleSaveDraft}
                  isSubmitting={isSubmitting}
                  isDraftSaving={isDraftSaving}
                />
              )}

              {/* Navigation Buttons */}
              <div className="flex flex-col sm:flex-row gap-3 pt-6 border-t border-gray-200">
                <Button
                  variant="outline"
                  onClick={handlePrevious}
                  disabled={currentStep === 1}
                  iconName="ChevronLeft"
                  iconPosition="left"
                  className="sm:w-auto"
                >
                  Previous
                </Button>

                <div className="flex flex-col sm:flex-row gap-3 sm:ml-auto">
                  <Button
                    variant="outline"
                    onClick={handleSaveDraft}
                    disabled={isDraftSaving}
                    iconName="Save"
                    iconPosition="left"
                  >
                    {isDraftSaving ? 'Saving...' : 'Save Draft'}
                  </Button>

                  {currentStep < steps.length && (
                    <Button
                      variant="primary"
                      onClick={handleNext}
                      iconName="ChevronRight"
                      iconPosition="right"
                    >
                      Next
                    </Button>
                  )}
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
);
};

export default CreateResourceListing;